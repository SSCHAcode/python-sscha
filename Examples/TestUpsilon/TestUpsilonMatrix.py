# -*- coding: utf-8 -*-

"""
In this example we test the stochastic evaluation of the covariance
matrix in the ensemble with the Upsilon computed by the Phonons package.

The test is performed both with the matrix that generated the ensemble
and with a different matrix, by exploiting the importance sampling.

To test, try to increase the number of configurations N, and check if the error
decreeses.
"""

import cellconstructor as CC
import cellconstructor.Phonons

import sscha
import sscha.Ensemble

import numpy as np
import sys, os


def test_upsilon_computation():
    # Go in this directory
    total_path = os.path.dirname(os.path.abspath(__file__))
    os.chdir(total_path)

    
    
    # The number of random configurations
    N = 6400
    STEP = 1

    # Load the dynamical matrix
    dyn_start = CC.Phonons.Phonons("dyn_start", full_name=True)
    nat = dyn_start.structure.N_atoms

    # Load the symmetrization (use a permissive threshold)
    qe_sym = CC.symmetries.QE_Symmetry(dyn_start.structure, 1e-2)
    qe_sym.SetupQPoint(verbose = True)

    # Impose the symmetries
    qe_sym.SymmetrizeDynQ(dyn_start.dynmats[0], np.array([0,0,0]))
    syms = qe_sym.GetSymmetries()
    dyn_start.structure.impose_symmetries(syms)

    # Generate a different dynamical matrix to test importance sampling
    # By mooving along a trivial generator
    gen_1 = np.zeros( (3*nat, 3*nat), dtype = np.float64)
    gen_1[0,0] = 1
    qe_sym.ImposeSumRule(gen_1, "crystal")
    qe_sym.SymmetrizeDynQ(gen_1, np.array([0,0,0]))
    new_dyn = dyn_start.Copy()
    new_dyn.dynmats[0] += gen_1 * STEP



    # Now get the covariance matrix from the ensemble generated by the same dynamical matrix
    ens = sscha.Ensemble.Ensemble(dyn_start, 0)
    ens.generate(N)



    # Get the upsilon matrix using the Phonon algorithm (T = 0)
    ups = dyn_start.GetUpsilonMatrix(0)

    cov_stoc = ens.get_covmat_from_ensemble() * sscha.Ensemble.__A_TO_BOHR__ **2

    # Impose the symmetries also in the covariance matrix
    qe_sym.SymmetrizeDynQ(cov_stoc, np.array([0,0,0]))
    qe_sym.ImposeSumRule(cov_stoc)

    identity = ups.dot(cov_stoc)

    # Diagonalize the identity matrix
    vals = np.linalg.eigvals(identity)
    vals = vals[ abs(vals) > 1e-4]

    #print "Eigenvals of the identity:", vals -1
    print ("Original ensembe: N = %d | d = " % N, np.sqrt(np.sum ((vals-1)**2)))

    # Update the weight with the new dynamical matrix
    ens.update_weights(new_dyn, 0)

    ups = new_dyn.GetUpsilonMatrix(0)
    cov_stoc = ens.get_covmat_from_ensemble() * sscha.Ensemble.__A_TO_BOHR__ **2
    qe_sym.SymmetrizeDynQ(cov_stoc, np.array([0,0,0]))
    qe_sym.ImposeSumRule(cov_stoc)
    identity = ups.dot(cov_stoc)
    # Diagonalize the identity matrix
    vals = np.linalg.eigvals(identity)
    vals = vals[ abs(vals) > 1e-4]

    #print "Eigenvals of the identity:", vals -1
    print ("IS ensembe: N = %d | N_eff = %d | d = " % (N, ens.get_effective_sample_size()), np.sqrt(np.sum ((vals-1)**2)))


if __name__ == "__main__":
    test_upsilon_computation()
